// File: tree.cc
// This is a simple test program.
// Modified by Rene Brun and Axcel Naumann to put the Pythia::event 
// into a TTree.
// Copyright (C) 2013 Torbjorn Sjostrand

// Header file to access Pythia 8 program elements.
#include "Pythia8/Pythia.h"

// ROOT, for saving Pythia events as trees in a file.
#include "TTree.h"
#include "TFile.h"

using namespace Pythia8;

int main() {

  // Create Pythia instance and set it up to generate hard QCD processes
  // above pTHat = 20 GeV for pp collisions at 14 TeV.
  
  Pythia pythia;
  
  // Shorthand for the event record in pythia. LHC settings.
  Event& event = pythia.event;
  ParticleData& particleData = pythia.particleData;
  pythia.readString("Beams:eCM = 14000.");
  
  // Extract settings to be used in the main program.
  //int nEvent = pythia.mode("Main:numberOfEvents");
  int nEvent = 50000;
  int nAbort = pythia.mode("Main:timesAllowErrors");
  
  
  
  
  pythia.readFile("/home/bouchiba/PDM/pythia8240/cmdfiles/HNLprop.cmnd");
  
  
  /***  Processes selection  ***/
  pythia.readString("HardQCD:all = on");
  pythia.readString("HardQCD:hardbbbar=on");
  pythia.readString("WeakSingleBoson:all=on");
  pythia.readString("WeakSingleBoson:ffbar2W = on");
  
 
  //pythia.readString("WeakBosonExchange:all=on");
  //pythia.readString("WeakBosonAndParton:all=on");
  //pythia.readString("WeakSingleBoson:ffbar2gmZ = on");	
  //pythia.readString("LeftRightSymmmetry:all=on");
  
  //pythia.readString("TwoFermions2W2TwoFermion=on");
  pythia.readString("WeakSingleBoson:ffbar2ffbar(s:W)=on");
  //pythia.readString("WeakSingleBoson:ffbar2gmZ = on");	

  // Conditions on daughters  
  pythia.readString("PhaseSpace:pTHatMin = 20.");
  
// Initialisation
  // pythia.readString("Init:showAllParticleData=on");
  pythia.readString("Next:numberShowEvent=10");
  pythia.init(); 					//take its values from the beam specification stored in the Settings database

  

  // Interesting amounts
  Double_t mu_P2(0), mu_PX(0), mu_PY(0), mu_PZ(0), mu_PT(0), mu_E(0);
  Double_t pi_P2(0), pi_PX(0), pi_PY(0), pi_PZ(0), pi_PT(0), pi_E(0);
  Double_t N_P2(0),  N_PX(0),  N_PY(0),  N_PZ(0),  N_PT(0),  N_E(0);

  // Set up the ROOT TFile and TTree.
  TFile *file = TFile::Open("pytree.root","recreate");
  //Event *event = &pythia.event;
  TTree *T = new TTree("T","mytree");
  //T->Branch("event",&event);
  //TBranch b_mu_P2("mu_P2",&mu_P2);
  
  TBranch *b_mu_PX = T->Branch("mu_PX",&mu_PX, "mu_PX/D");
  TBranch *b_mu_PY = T->Branch("mu_PY",&mu_PY, "mu_PY/D");
  TBranch *b_mu_PZ = T->Branch("mu_PZ",&mu_PZ, "mu_PZ/D");
  TBranch *b_mu_PT = T->Branch("mu_PT",&mu_PT, "mu_PT/D");
  TBranch *b_mu_E  = T->Branch("mu_E",&mu_E,   "mu_E/D");
  
  //Branch b_pi_P2("pi_P2",&pi_P2);
  TBranch *b_pi_PX = T->Branch("pi_PX",&pi_PX, "pi_PX/D");
  TBranch *b_pi_PY = T->Branch("pi_PY",&pi_PY, "pi_PY/D");
  TBranch *b_pi_PZ = T->Branch("pi_PZ",&pi_PZ, "pi_PZ/D");
  TBranch *b_pi_PT = T->Branch("pi_PT",&pi_PT, "pi_PT/D");
  TBranch *b_pi_E  = T->Branch("pi_E",&pi_E,   "pi_E/D");
  
  //Branch b_N_P2("N_P2",&N_P2);
  TBranch *b_N_PX = T->Branch("N_PX",&N_PX, "N_PX/D");
  TBranch *b_N_PY = T->Branch("N_PY",&N_PY, "N_PY/D");
  TBranch *b_N_PZ = T->Branch("N_PZ",&N_PZ, "N_PZ/D");
  TBranch *b_N_PT = T->Branch("N_PT",&N_PT, "N_PT/D");
  TBranch *b_N_E  = T->Branch("N_E",&N_E,   "N_E/D");
  

 
 
  
  int iAbort = 0;
  //int nEvent = 2000;
  for (int iEvent = 0; iEvent < nEvent; ++iEvent) {

    // Generate events. Quit if many failures.
     // Generate events. Quit if many failures.
    if (!pythia.next()) {
      if (++iAbort < nAbort) continue;
      cout << " Event generation aborted prematurely, owing to error!\n";
      break;
    }

    // Loop over all particles and analyze the final-state ones.
   for (int i = 0; i < pythia.event.size(); ++i){
    if (pythia.event[i].isFinal()) {
		//cout << endl<<endl<<endl<<"     HELLOOOOOOO\n \n \n"   ;
      int idAbs = pythia.event[i].idAbs();
      double EI = pythia.event[i].e();
      //double P2I = pythia.event[i].p2();
      double PXI = pythia.event[i].px();
      double PYI = pythia.event[i].py();
      double PZI = pythia.event[i].pz();
      double PTI = pythia.event[i].pT();
      
      if (idAbs == 13){
		mu_E=EI; 	//mu_P2=P2I; 	
		mu_PT=PTI;
		mu_PX=PXI; 	mu_PY=PYI; 	mu_PZ=PZI;
		//cout << "mu !" << endl;
		/*
		b_mu_PX->Fill(); 
		b_mu_PY->Fill(); 
		b_mu_PZ->Fill(); 
		b_mu_PT->Fill(); 
		b_mu_E->Fill(); 
		*/
	  }
      else if (idAbs == 211){
	    pi_E=EI; 	//pi_P2=P2I; 	
	    pi_PT=PTI;
		pi_PX=PXI; 	pi_PY=PYI; 	pi_PZ=PZI;
		//cout << "pi !" << endl;
		/*
		b_pi_PX->Fill(); 
		b_pi_PY->Fill(); 
		b_pi_PZ->Fill(); 
		b_pi_PT->Fill(); 
		b_pi_E->Fill();
		*/ 
	  }
	  
	  else if (idAbs == 14){
	    N_E=EI; 	//N_P=P2I; 	
	    N_PT=PTI;
		N_PX=PXI; 	N_PY=PYI; 	N_PZ=PZI;
		cout << "N !" << endl;
		/*
		b_N_PX->Fill(); 
		b_N_PY->Fill(); 
		b_N_PZ->Fill(); 
		b_N_PT->Fill(); 
		b_N_E->Fill(); 
		*/
	  }
	  
	  T->Fill();
    
    }
  }
  
  // End of event loop.
  }
  
  // Statistics on event generation.
  pythia.stat();

  //  Write tree.
  T->Print();
  T->Write();
  delete T;
  delete file;

  // Done.
  return 0;
}
